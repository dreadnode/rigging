---
title: rigging.tool
---

{/*
::: rigging.tool
::: rigging.tool.base
::: rigging.tool.native
::: rigging.tool.mcp
::: rigging.tool.robopages
*/}

This module defines handles tool interaction with rigging generation.

Tool
----

```python
Tool(
    name: str,
    description: str,
    parameters_schema: dict[str, Any],
    fn: Callable[P, R],
    catch: bool | set[type[Exception]] = False,
    truncate: int | None = None,
)
```

Base class for representing a tool to a generator.

### catch

```python
catch: bool | set[type[Exception]] = False
```

Whether to catch exceptions and return them as messages.

* `False`: Do not catch exceptions.
* `True`: Catch all exceptions.
* `list[type[Exception]]`: Catch only the specified exceptions.

### description

```python
description: str
```

A description of the tool.

### fn

```python
fn: Callable[P, R]
```

The function to call.

### name

```python
name: str
```

The name of the tool.

### parameters\_schema

```python
parameters_schema: dict[str, Any]
```

The JSON schema for the tool's parameters.

### truncate

```python
truncate: int | None = None
```

If set, the maximum number of characters to truncate any tool output to.

### handle\_tool\_call

```python
handle_tool_call(
    tool_call: ApiToolCall
    | XmlToolCall
    | JsonInXmlToolCall,
) -> tuple[Message, bool]
```

Handle an incoming tool call from a generator.

**Parameters:**

* **`tool_call`**
  (`ApiToolCall | XmlToolCall | JsonInXmlToolCall`)
  –The tool call to handle.

**Returns:**

* `Message`
  –A tuple containing the message to send back to the generator and a
* `bool`
  –boolean indicating whether tool calling should stop.

<Accordion title="Source code in rigging/tool/base.py" icon="code">
```python
async def handle_tool_call(  # noqa: PLR0912, PLR0915
    self,
    tool_call: ApiToolCall | XmlToolCall | JsonInXmlToolCall,
) -> tuple["Message", bool]:
    """
    Handle an incoming tool call from a generator.

    Args:
        tool_call: The tool call to handle.

    Returns:
        A tuple containing the message to send back to the generator and a
        boolean indicating whether tool calling should stop.
    """

    from rigging.message import ContentText, ContentTypes, Message

    tool_call_parameters = (
        tool_call.function.arguments
        if isinstance(tool_call, ApiToolCall)
        else tool_call.parameters
    )

    with tracer.span(f"Tool {self.name}()", name=self.name) as span:
        if tool_call.name != self.name:
            raise ValueError(
                f"Requested function name '{tool_call.name}' does not match '{self.name}'",
            )

        if isinstance(tool_call, ApiToolCall):
            span.set_attribute("tool_call_id", tool_call.id)

        # Load + validate arguments

        kwargs: dict[str, t.Any]
        if isinstance(tool_call, ApiToolCall | JsonInXmlToolCall):
            kwargs = json.loads(tool_call_parameters)

            if self._type_adapter is not None:
                kwargs = self._type_adapter.validate_python(kwargs)

        elif isinstance(tool_call, XmlToolCall):
            try:
                parsed = self.model.from_text(
                    self.model.xml_start_tag()
                    + tool_call_parameters
                    + self.model.xml_end_tag(),
                )
            except Exception as e:
                raise ValueError(
                    f"Failed to parse parameters from:\n{tool_call_parameters}",
                ) from e

            if not parsed:
                raise ValueError(
                    f"Failed to parse parameters from:\n{tool_call_parameters}",
                )

            parameters = parsed[0][0]

            # As opposed to a model_dump, we want to retain the
            # argument object instances. We'll just flatten the
            # model into a dictionary for the function call.

            kwargs = {
                field_name: getattr(parameters, field_name, None)
                for field_name in self.model.model_fields
            }

        span.set_attribute("arguments", kwargs)

        # Call the function

        stop = False

        try:
            result: t.Any = self.fn(**kwargs)  # type: ignore [call-arg]
            if inspect.isawaitable(result):
                result = await result
        except Stop as e:
            result = f"<rg:stop>{e.message}</rg:stop>"
            span.set_attribute("stop", True)
            stop = True
        except Exception as e:
            if self.catch is True or (
                not isinstance(self.catch, bool) and isinstance(e, tuple(self.catch))
            ):
                result = f'<error type="{e.__class__.__name__}">{e}</error>'
            else:
                raise

        span.set_attribute("result", result)

    message = (
        Message(role="tool", tool_call_id=tool_call.id)
        if isinstance(tool_call, ApiToolCall)
        else Message("user")
    )

    # If the tool gave us back anything that looks like a message, we'll
    # just pass it along. Otherwise we need to box up the result.

    if isinstance(result, Message):
        message.content_parts = result.content_parts
    elif isinstance(result, ContentTypes):
        message.content_parts = [result]
    elif (
        isinstance(result, list)
        and result
        and all(isinstance(item, ContentTypes) for item in result)
    ):
        message.content_parts = result
    else:
        message.content_parts = [ContentText(text=str(result))]

    if self.truncate:
        message = message.truncate(self.truncate)

    # If this is a native tool call, we should wrap up our
    # result in a NativeToolResult object to provide clarity to the
    # generator. Otherwise we can rely on the `tool` role and associated
    # tool_call_id to provide context.
    #
    # TODO: It would be great to have some kind of identifier here to let
    # the model know what result is associated with what tool call when
    # we aren't working with api calls
    #
    # (we'd likely have to insert the shared identifier upstream in the call)

    if (
        len(message.content_parts) == 1
        and isinstance(message.content_parts[0], ContentText)
        and isinstance(tool_call, XmlToolCall | JsonInXmlToolCall)
    ):
        message.content_parts[0].text = NativeToolResult(
            name=self.name,
            result=message.content_parts[0].text,
        ).to_pretty_xml()

    return message, stop
```


</Accordion>

tool
----

```python
tool(
    func: None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[[t.Callable[P, R]], Tool[P, R]]
```

```python
tool(func: Callable[P, R]) -> Tool[P, R]
```

```python
tool(
    func: Callable[P, R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> (
    t.Callable[[t.Callable[P, R]], Tool[P, R]] | Tool[P, R]
)
```

Decorator for creating a Tool, useful for overriding a name or description.

**Parameters:**

* **`func`**
  (`Callable[P, R] | None`, default:
  `None`
  )
  –The function to wrap.
* **`name`**
  (`str | None`, default:
  `None`
  )
  –The name of the tool.
* **`description`**
  (`str | None`, default:
  `None`
  )
  –The description of the tool.
* **`catch`**
  (`bool | Iterable[type[Exception]]`, default:
  `False`
  )
  –Whether to catch exceptions and return them as messages.
  - `False`: Do not catch exceptions.
  - `True`: Catch all exceptions.
  - `list[type[Exception]]`: Catch only the specified exceptions.
* **`truncate`**
  (`int | None`, default:
  `None`
  )
  –If set, the maximum number of characters to truncate any tool output to.

**Returns:**

* `Callable[[Callable[P, R]], Tool[P, R]] | Tool[P, R]`
  –The decorated Tool object.

Example

```python
@tool(name="add_numbers", description="This is my tool")
def add(x: int, y: int) -> int:
    return x + y
```


<Accordion title="Source code in rigging/tool/base.py" icon="code">
```python
def tool(
    func: t.Callable[P, R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | t.Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[[t.Callable[P, R]], Tool[P, R]] | Tool[P, R]:
    """
    Decorator for creating a Tool, useful for overriding a name or description.

    Args:
        func: The function to wrap.
        name: The name of the tool.
        description: The description of the tool.
        catch: Whether to catch exceptions and return them as messages.
            - `False`: Do not catch exceptions.
            - `True`: Catch all exceptions.
            - `list[type[Exception]]`: Catch only the specified exceptions.
        truncate: If set, the maximum number of characters to truncate any tool output to.

    Returns:
        The decorated Tool object.

    Example:
        ~~~
        @tool(name="add_numbers", description="This is my tool")
        def add(x: int, y: int) -> int:
            return x + y
        ~~~
    """

    def make_tool(func: t.Callable[..., t.Any]) -> Tool[P, R]:
        if _is_unbound_method(func):
            warnings.warn(
                "Passing a class method to @tool improperly handles the 'self' argument, use @tool_method instead.",
                SyntaxWarning,
                stacklevel=3,
            )

        return Tool.from_callable(
            func,
            name=name,
            description=description,
            catch=catch,
            truncate=truncate,
        )

    if func is not None:
        return make_tool(func)

    return make_tool
```


</Accordion>

tool\_method
------------

```python
tool_method(
    func: None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[
    [t.Callable[t.Concatenate[t.Any, P], R]],
    ToolMethod[P, R],
]
```

```python
tool_method(
    func: Callable[Concatenate[Any, P], R],
) -> ToolMethod[P, R]
```

```python
tool_method(
    func: Callable[Concatenate[Any, P], R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> (
    t.Callable[
        [t.Callable[t.Concatenate[t.Any, P], R]],
        ToolMethod[P, R],
    ]
    | ToolMethod[P, R]
)
```

Decorator for creating a Tool from a class method.

The tool produced from this method will be incomplete until it is called
from an instantiated class. If you don't require any active state from
a `self` argument, consider wrapping a method first with `@staticmethod`
and then using `@tool` to create a tool from it.

See `@tool` for more details.

Example

```python
class Thing:
    delta: int = 5

    @tool_method(name="add_numbers_with_delta", description="This is my tool")
    def delta_add(self, x: int, y: int) -> int:
        return x + y + self.delta

    @tool(name="add_numbers", description="This is my tool")
    @staticmethod
    def static_add(x: int, y: int) -> int:
        return x + y
```


<Accordion title="Source code in rigging/tool/base.py" icon="code">
```python
def tool_method(
    func: t.Callable[t.Concatenate[t.Any, P], R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | t.Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[[t.Callable[t.Concatenate[t.Any, P], R]], ToolMethod[P, R]] | ToolMethod[P, R]:
    """
    Decorator for creating a Tool from a class method.

    The tool produced from this method will be incomplete until it is called
    from an instantiated class. If you don't require any active state from
    a `self` argument, consider wrapping a method first with `@staticmethod`
    and then using `@tool` to create a tool from it.

    See `@tool` for more details.

    Example:
        ~~~
        class Thing:
            delta: int = 5

            @tool_method(name="add_numbers_with_delta", description="This is my tool")
            def delta_add(self, x: int, y: int) -> int:
                return x + y + self.delta

            @tool(name="add_numbers", description="This is my tool")
            @staticmethod
            def static_add(x: int, y: int) -> int:
                return x + y
        ~~~
    """

    def make_tool(func: t.Callable[..., t.Any]) -> ToolMethod[P, R]:
        if not _is_unbound_method(func):
            warnings.warn(
                "Passing a regular function to @tool_method improperly handles the 'self' argument, use @tool instead.",
                SyntaxWarning,
                stacklevel=3,
            )

        # Strip the `self` argument from the function signature so
        # our schema generation doesn't include it under the hood.

        @functools.wraps(func)
        def wrapper(self: t.Any, *args: P.args, **kwargs: P.kwargs) -> R:
            return func(self, *args, **kwargs)  # type: ignore [no-any-return]

        wrapper.__signature__ = inspect.signature(func).replace(  # type: ignore [attr-defined]
            parameters=tuple(
                param
                for param in inspect.signature(func).parameters.values()
                if param.name != "self"
            ),
        )

        return ToolMethod.from_callable(
            wrapper,  # type: ignore [arg-type]
            name=name,
            description=description,
            catch=catch,
            truncate=truncate,
        )

    if func is not None:
        return make_tool(func)

    return make_tool
```


</Accordion>
Core types and functions for defining tools and handling tool calls.

ToolMode
--------

```python
ToolMode = Literal['auto', 'api', 'xml', 'json-in-xml']
```

How tool calls are handled.

* `auto`: The method is chosen based on support (api > xml).
* `api`: Tool calls are delegated to api-provided function calling.
* `xml`: Tool calls are parsed in nested XML format.
* `json-in-xml`: Tool calls are parsed as raw JSON inside XML tags.

Tool
----

```python
Tool(
    name: str,
    description: str,
    parameters_schema: dict[str, Any],
    fn: Callable[P, R],
    catch: bool | set[type[Exception]] = False,
    truncate: int | None = None,
)
```

Base class for representing a tool to a generator.

### catch

```python
catch: bool | set[type[Exception]] = False
```

Whether to catch exceptions and return them as messages.

* `False`: Do not catch exceptions.
* `True`: Catch all exceptions.
* `list[type[Exception]]`: Catch only the specified exceptions.

### description

```python
description: str
```

A description of the tool.

### fn

```python
fn: Callable[P, R]
```

The function to call.

### name

```python
name: str
```

The name of the tool.

### parameters\_schema

```python
parameters_schema: dict[str, Any]
```

The JSON schema for the tool's parameters.

### truncate

```python
truncate: int | None = None
```

If set, the maximum number of characters to truncate any tool output to.

### handle\_tool\_call

```python
handle_tool_call(
    tool_call: ApiToolCall
    | XmlToolCall
    | JsonInXmlToolCall,
) -> tuple[Message, bool]
```

Handle an incoming tool call from a generator.

**Parameters:**

* **`tool_call`**
  (`ApiToolCall | XmlToolCall | JsonInXmlToolCall`)
  –The tool call to handle.

**Returns:**

* `Message`
  –A tuple containing the message to send back to the generator and a
* `bool`
  –boolean indicating whether tool calling should stop.

<Accordion title="Source code in rigging/tool/base.py" icon="code">
```python
async def handle_tool_call(  # noqa: PLR0912, PLR0915
    self,
    tool_call: ApiToolCall | XmlToolCall | JsonInXmlToolCall,
) -> tuple["Message", bool]:
    """
    Handle an incoming tool call from a generator.

    Args:
        tool_call: The tool call to handle.

    Returns:
        A tuple containing the message to send back to the generator and a
        boolean indicating whether tool calling should stop.
    """

    from rigging.message import ContentText, ContentTypes, Message

    tool_call_parameters = (
        tool_call.function.arguments
        if isinstance(tool_call, ApiToolCall)
        else tool_call.parameters
    )

    with tracer.span(f"Tool {self.name}()", name=self.name) as span:
        if tool_call.name != self.name:
            raise ValueError(
                f"Requested function name '{tool_call.name}' does not match '{self.name}'",
            )

        if isinstance(tool_call, ApiToolCall):
            span.set_attribute("tool_call_id", tool_call.id)

        # Load + validate arguments

        kwargs: dict[str, t.Any]
        if isinstance(tool_call, ApiToolCall | JsonInXmlToolCall):
            kwargs = json.loads(tool_call_parameters)

            if self._type_adapter is not None:
                kwargs = self._type_adapter.validate_python(kwargs)

        elif isinstance(tool_call, XmlToolCall):
            try:
                parsed = self.model.from_text(
                    self.model.xml_start_tag()
                    + tool_call_parameters
                    + self.model.xml_end_tag(),
                )
            except Exception as e:
                raise ValueError(
                    f"Failed to parse parameters from:\n{tool_call_parameters}",
                ) from e

            if not parsed:
                raise ValueError(
                    f"Failed to parse parameters from:\n{tool_call_parameters}",
                )

            parameters = parsed[0][0]

            # As opposed to a model_dump, we want to retain the
            # argument object instances. We'll just flatten the
            # model into a dictionary for the function call.

            kwargs = {
                field_name: getattr(parameters, field_name, None)
                for field_name in self.model.model_fields
            }

        span.set_attribute("arguments", kwargs)

        # Call the function

        stop = False

        try:
            result: t.Any = self.fn(**kwargs)  # type: ignore [call-arg]
            if inspect.isawaitable(result):
                result = await result
        except Stop as e:
            result = f"<rg:stop>{e.message}</rg:stop>"
            span.set_attribute("stop", True)
            stop = True
        except Exception as e:
            if self.catch is True or (
                not isinstance(self.catch, bool) and isinstance(e, tuple(self.catch))
            ):
                result = f'<error type="{e.__class__.__name__}">{e}</error>'
            else:
                raise

        span.set_attribute("result", result)

    message = (
        Message(role="tool", tool_call_id=tool_call.id)
        if isinstance(tool_call, ApiToolCall)
        else Message("user")
    )

    # If the tool gave us back anything that looks like a message, we'll
    # just pass it along. Otherwise we need to box up the result.

    if isinstance(result, Message):
        message.content_parts = result.content_parts
    elif isinstance(result, ContentTypes):
        message.content_parts = [result]
    elif (
        isinstance(result, list)
        and result
        and all(isinstance(item, ContentTypes) for item in result)
    ):
        message.content_parts = result
    else:
        message.content_parts = [ContentText(text=str(result))]

    if self.truncate:
        message = message.truncate(self.truncate)

    # If this is a native tool call, we should wrap up our
    # result in a NativeToolResult object to provide clarity to the
    # generator. Otherwise we can rely on the `tool` role and associated
    # tool_call_id to provide context.
    #
    # TODO: It would be great to have some kind of identifier here to let
    # the model know what result is associated with what tool call when
    # we aren't working with api calls
    #
    # (we'd likely have to insert the shared identifier upstream in the call)

    if (
        len(message.content_parts) == 1
        and isinstance(message.content_parts[0], ContentText)
        and isinstance(tool_call, XmlToolCall | JsonInXmlToolCall)
    ):
        message.content_parts[0].text = NativeToolResult(
            name=self.name,
            result=message.content_parts[0].text,
        ).to_pretty_xml()

    return message, stop
```


</Accordion>

ToolMethod
----------

```python
ToolMethod(
    name: str,
    description: str,
    parameters_schema: dict[str, Any],
    fn: Callable[P, R],
    catch: bool | set[type[Exception]] = False,
    truncate: int | None = None,
)
```

A Tool wrapping a class method.

tool
----

```python
tool(
    func: None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[[t.Callable[P, R]], Tool[P, R]]
```

```python
tool(func: Callable[P, R]) -> Tool[P, R]
```

```python
tool(
    func: Callable[P, R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> (
    t.Callable[[t.Callable[P, R]], Tool[P, R]] | Tool[P, R]
)
```

Decorator for creating a Tool, useful for overriding a name or description.

**Parameters:**

* **`func`**
  (`Callable[P, R] | None`, default:
  `None`
  )
  –The function to wrap.
* **`name`**
  (`str | None`, default:
  `None`
  )
  –The name of the tool.
* **`description`**
  (`str | None`, default:
  `None`
  )
  –The description of the tool.
* **`catch`**
  (`bool | Iterable[type[Exception]]`, default:
  `False`
  )
  –Whether to catch exceptions and return them as messages.
  - `False`: Do not catch exceptions.
  - `True`: Catch all exceptions.
  - `list[type[Exception]]`: Catch only the specified exceptions.
* **`truncate`**
  (`int | None`, default:
  `None`
  )
  –If set, the maximum number of characters to truncate any tool output to.

**Returns:**

* `Callable[[Callable[P, R]], Tool[P, R]] | Tool[P, R]`
  –The decorated Tool object.

Example

```python
@tool(name="add_numbers", description="This is my tool")
def add(x: int, y: int) -> int:
    return x + y
```


<Accordion title="Source code in rigging/tool/base.py" icon="code">
```python
def tool(
    func: t.Callable[P, R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | t.Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[[t.Callable[P, R]], Tool[P, R]] | Tool[P, R]:
    """
    Decorator for creating a Tool, useful for overriding a name or description.

    Args:
        func: The function to wrap.
        name: The name of the tool.
        description: The description of the tool.
        catch: Whether to catch exceptions and return them as messages.
            - `False`: Do not catch exceptions.
            - `True`: Catch all exceptions.
            - `list[type[Exception]]`: Catch only the specified exceptions.
        truncate: If set, the maximum number of characters to truncate any tool output to.

    Returns:
        The decorated Tool object.

    Example:
        ~~~
        @tool(name="add_numbers", description="This is my tool")
        def add(x: int, y: int) -> int:
            return x + y
        ~~~
    """

    def make_tool(func: t.Callable[..., t.Any]) -> Tool[P, R]:
        if _is_unbound_method(func):
            warnings.warn(
                "Passing a class method to @tool improperly handles the 'self' argument, use @tool_method instead.",
                SyntaxWarning,
                stacklevel=3,
            )

        return Tool.from_callable(
            func,
            name=name,
            description=description,
            catch=catch,
            truncate=truncate,
        )

    if func is not None:
        return make_tool(func)

    return make_tool
```


</Accordion>

tool\_method
------------

```python
tool_method(
    func: None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[
    [t.Callable[t.Concatenate[t.Any, P], R]],
    ToolMethod[P, R],
]
```

```python
tool_method(
    func: Callable[Concatenate[Any, P], R],
) -> ToolMethod[P, R]
```

```python
tool_method(
    func: Callable[Concatenate[Any, P], R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> (
    t.Callable[
        [t.Callable[t.Concatenate[t.Any, P], R]],
        ToolMethod[P, R],
    ]
    | ToolMethod[P, R]
)
```

Decorator for creating a Tool from a class method.

The tool produced from this method will be incomplete until it is called
from an instantiated class. If you don't require any active state from
a `self` argument, consider wrapping a method first with `@staticmethod`
and then using `@tool` to create a tool from it.

See `@tool` for more details.

Example

```python
class Thing:
    delta: int = 5

    @tool_method(name="add_numbers_with_delta", description="This is my tool")
    def delta_add(self, x: int, y: int) -> int:
        return x + y + self.delta

    @tool(name="add_numbers", description="This is my tool")
    @staticmethod
    def static_add(x: int, y: int) -> int:
        return x + y
```


<Accordion title="Source code in rigging/tool/base.py" icon="code">
```python
def tool_method(
    func: t.Callable[t.Concatenate[t.Any, P], R] | None = None,
    /,
    *,
    name: str | None = None,
    description: str | None = None,
    catch: bool | t.Iterable[type[Exception]] = False,
    truncate: int | None = None,
) -> t.Callable[[t.Callable[t.Concatenate[t.Any, P], R]], ToolMethod[P, R]] | ToolMethod[P, R]:
    """
    Decorator for creating a Tool from a class method.

    The tool produced from this method will be incomplete until it is called
    from an instantiated class. If you don't require any active state from
    a `self` argument, consider wrapping a method first with `@staticmethod`
    and then using `@tool` to create a tool from it.

    See `@tool` for more details.

    Example:
        ~~~
        class Thing:
            delta: int = 5

            @tool_method(name="add_numbers_with_delta", description="This is my tool")
            def delta_add(self, x: int, y: int) -> int:
                return x + y + self.delta

            @tool(name="add_numbers", description="This is my tool")
            @staticmethod
            def static_add(x: int, y: int) -> int:
                return x + y
        ~~~
    """

    def make_tool(func: t.Callable[..., t.Any]) -> ToolMethod[P, R]:
        if not _is_unbound_method(func):
            warnings.warn(
                "Passing a regular function to @tool_method improperly handles the 'self' argument, use @tool instead.",
                SyntaxWarning,
                stacklevel=3,
            )

        # Strip the `self` argument from the function signature so
        # our schema generation doesn't include it under the hood.

        @functools.wraps(func)
        def wrapper(self: t.Any, *args: P.args, **kwargs: P.kwargs) -> R:
            return func(self, *args, **kwargs)  # type: ignore [no-any-return]

        wrapper.__signature__ = inspect.signature(func).replace(  # type: ignore [attr-defined]
            parameters=tuple(
                param
                for param in inspect.signature(func).parameters.values()
                if param.name != "self"
            ),
        )

        return ToolMethod.from_callable(
            wrapper,  # type: ignore [arg-type]
            name=name,
            description=description,
            catch=catch,
            truncate=truncate,
        )

    if func is not None:
        return make_tool(func)

    return make_tool
```


</Accordion>
Models and utilities for defining and working with native-parsed tools.
Utilities for communicating with MCP servers.

MCPClient
---------

```python
MCPClient(
    transport: Transport,
    connection: StdioConnection | SSEConnection,
)
```

A client for communicating with MCP servers.

<Accordion title="Source code in rigging/tool/mcp.py" icon="code">
```python
def __init__(self, transport: Transport, connection: StdioConnection | SSEConnection) -> None:
    self.transport = transport
    self.connection = connection
    self.tools = []
    self._exit_stack = AsyncExitStack()
    self._session: ClientSession | None = None
```


</Accordion>

### connection

```python
connection: StdioConnection | SSEConnection = connection
```

Connection configuration

### tools

```python
tools: list[Tool[..., Any]] = []
```

A list of tools available on the server

### transport

```python
transport: Transport = transport
```

The transport to use
Utilities for integrating tools from a Robopages server.

robopages
---------

```python
robopages(
    url: str, *, name_filter: str | None = None
) -> list[Tool[..., t.Any]]
```

Create a list of tools from a Robopages server.

**Parameters:**

* **`url`**
  (`str`)
  –The URL of the Robopages server.
* **`name_filter`**
  (`str | None`, default:
  `None`
  )
  –A regular expression to filter the tools by name.

**Returns:**

* `list[Tool[..., Any]]`
  –A list of integrated tools which leverage the Robopages server.

Example

```python
import rigging as rg

tools = rg.tool.robopages("http://localhost:8080")

chat = (
    await rg.get_generator('gpt-4o')
    .chat('Please use tools')
    .using(*tools)
    .run()
)

print(chat.conversation)
```


<Accordion title="Source code in rigging/tool/robopages.py" icon="code">
```python
def robopages(url: str, *, name_filter: str | None = None) -> list[Tool[..., t.Any]]:
    """
    Create a list of tools from a Robopages server.

    Args:
        url: The URL of the Robopages server.
        name_filter: A regular expression to filter the tools by name.

    Returns:
        A list of integrated tools which leverage the Robopages server.

    Example:
        ~~~
        import rigging as rg

        tools = rg.tool.robopages("http://localhost:8080")

        chat = (
            await rg.get_generator('gpt-4o')
            .chat('Please use tools')
            .using(*tools)
            .run()
        )

        print(chat.conversation)
        ~~~
    """

    filter_regex = re.compile(name_filter) if name_filter else None

    response = requests.get(url, params={"flavor": "openai"}, timeout=DEFAULT_HTTP_TIMEOUT)
    response.raise_for_status()
    tools_data = response.json()

    adapter = TypeAdapter(list[ApiToolDefinition])
    tool_definitions = adapter.validate_python(tools_data)

    logger.info(f"Fetched {len(tool_definitions)} functions from Robopages ({url})")

    tools: list[Tool[..., t.Any]] = []
    for definition in tool_definitions:
        function = definition.function

        if filter_regex and not filter_regex.search(function.name):
            logger.debug(f"Skipping function {function.name}")
            continue

        tools.append(
            Tool(
                function.name,
                function.description or "",
                function.parameters or {},
                make_execute_on_server(url, function.name),
            ),
        )

    return tools
```


</Accordion>